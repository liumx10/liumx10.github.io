<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>lock-free | Dreamworks</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="lock free 简介本文是一个翻译，是一个总结，原链接
what is it首先，lock free的概念不仅仅是代码中不使用mutex之类的东西。参考下图，如果一路yes，说明是lock free，如果前面条件不满足，说明也不是lock free。

lock free就是说，不会用锁；也不会因为潜在的线程调度导致bug。比如两个线程，同时执行下面代码，其中，x是共享变量：
while(x=">
<meta property="og:type" content="article">
<meta property="og:title" content="lock-free">
<meta property="og:url" content="http://liumx10.github.io/2016/03/07/lock-free/index.html">
<meta property="og:site_name" content="Dreamworks">
<meta property="og:description" content="lock free 简介本文是一个翻译，是一个总结，原链接
what is it首先，lock free的概念不仅仅是代码中不使用mutex之类的东西。参考下图，如果一路yes，说明是lock free，如果前面条件不满足，说明也不是lock free。

lock free就是说，不会用锁；也不会因为潜在的线程调度导致bug。比如两个线程，同时执行下面代码，其中，x是共享变量：
while(x=">
<meta property="og:image" content="http://preshing.com/images/its-lock-free.png">
<meta property="og:image" content="http://preshing.com/images/techniques.png">
<meta property="og:updated_time" content="2016-03-07T13:58:02.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lock-free">
<meta name="twitter:description" content="lock free 简介本文是一个翻译，是一个总结，原链接
what is it首先，lock free的概念不仅仅是代码中不使用mutex之类的东西。参考下图，如果一路yes，说明是lock free，如果前面条件不满足，说明也不是lock free。

lock free就是说，不会用锁；也不会因为潜在的线程调度导致bug。比如两个线程，同时执行下面代码，其中，x是共享变量：
while(x=">
<meta name="twitter:image" content="http://preshing.com/images/its-lock-free.png">
  
    <link rel="alternate" href="/atom.xml" title="Dreamworks" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Dreamworks</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        <a id="nav-search-btn" class="nav-icon" title="Zoeken"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://liumx10.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-lock-free" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/07/lock-free/" class="article-date">
  <time datetime="2016-03-07T12:54:48.000Z" itemprop="datePublished">2016-03-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      lock-free
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="lock-free-简介"><a href="#lock-free-简介" class="headerlink" title="lock free 简介"></a>lock free 简介</h2><p>本文是一个翻译，是一个总结，<a href="http://preshing.com/20120612/an-introduction-to-lock-free-programming/" target="_blank" rel="external">原链接</a></p>
<h2 id="what-is-it"><a href="#what-is-it" class="headerlink" title="what is it"></a>what is it</h2><p>首先，lock free的概念不仅仅是代码中不使用mutex之类的东西。参考下图，如果一路yes，说明是lock free，如果前面条件不满足，说明也不是lock free。</p>
<p><img src="http://preshing.com/images/its-lock-free.png" alt=""></p>
<p>lock free就是说，不会用锁；也不会因为潜在的线程调度导致bug。比如两个线程，同时执行下面代码，其中，x是共享变量：</p>
<pre><code>while(x==0)
    x = 1-x;
</code></pre><p>有一种可能性，是两个线程都不会跳出循环；(A 线程读x=0，B线程读x=0；A线程执行x=1-x，得到1，B线程执行x=1-x，得到0，回到开始的位置了。)所以这不是lock free</p>
<p><a href="http://www.amazon.com/gp/product/0123973376/ref=as_li_ss_tl?ie=UTF8&amp;tag=preshonprogr-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0123973376" target="_blank" rel="external">多处理器编程艺术</a>里面给了一个定义：”In an infinite execution, infinitely often some method call finishes.”就是说，只要有程序持续调用函数，已经完成的函数调用数目一直在增加。</p>
<p>一个重要的结果就是，如果一个lock free的程序某一个线程被挂起来，其他所有的程序都不会被阻塞。因此不需要设置time out之类的东西了。</p>
<h2 id="lock-free-的技术手段"><a href="#lock-free-的技术手段" class="headerlink" title="lock free 的技术手段"></a>lock free 的技术手段</h2><p><img src="http://preshing.com/images/techniques.png" alt=""></p>
<p>常规的手段显然是不行的，因此需要很多新的手段，按照这张图我们一个个分析。</p>
<h3 id="Atomic-Read-Modify-Write-Operations"><a href="#Atomic-Read-Modify-Write-Operations" class="headerlink" title="Atomic Read-Modify-Write Operations"></a>Atomic Read-Modify-Write Operations</h3><p>原子操作，指的是处理器执行指令，没有一个线程可以看到执行的中间状态。实际上，现代处理器，很多操作都是原子的，比如read/write memory的操作。</p>
<p>Read-Modify-Write更进一层，读内存-修改-写内存，三个操作集成到一个原子操作里；实际上就是一个transaction。现有的win32 里的 _InterlockedIncrement 指令，iOS里的 OSAtomicAdd32 指令，或者说，C++11里的std::atomic<int>::fetch_add。C++11相当于一个集成，在各个平台上未必都是lock free，这得看具体的情况；（个人猜测，c++11根据平台，尽可能利用底层的RMW指令，如果没有，就用软件实现）可以用std::atomic&lt;&gt;::is_lock_free 来确认。</int></p>
<p>从流程图中我们可以看出，即使是单线程程序，RMW也是有用的，因为它实现了一个transaction，避免操作出现一半中断了，带来错误的后果。</p>
<h3 id="Compare-And-Swap"><a href="#Compare-And-Swap" class="headerlink" title="Compare And Swap"></a>Compare And Swap</h3><p>可能最常见的RMW指令就是CAS，如果相同就更换。比如win32的指令就是_InterlockedCompareExchange，我们可以用CAS实现一个lock free队列：</p>
<pre><code>void LockFreeQueue::push(Node* newHead)
{
    for (;;)
    {
        // Copy a shared variable (m_Head) to a local.
        Node* oldHead = m_Head;

        // Do some speculative work, not yet visible to other threads.
        newHead-&gt;next = oldHead;

        // Next, attempt to publish our changes to the shared variable.
        // If the shared variable hasn&apos;t changed, the CAS succeeds and we return.
        // Otherwise, repeat.
        if (_InterlockedCompareExchange(&amp;m_Head, newHead, oldHead) == oldHead)
            return;
    }
}
</code></pre><p>这样即使有一个thread test失败，说明另外一个线程更改成功；所以这是一个lock free。_所有用到CAS指令的，需要小心<a href="https://en.wikipedia.org/wiki/ABA_problem" target="_blank" rel="external">ABA问题</a>_</p>
<h3 id="Sequential-Consistency"><a href="#Sequential-Consistency" class="headerlink" title="Sequential Consistency"></a>Sequential Consistency</h3><p>定义：所有线程有着相同的内存操作顺序，这种顺序与源代码相同。这样防止了处理器或者编译器的reorder。</p>
<p>在C++11中可以定义atomic对象，这样所有的操作都是顺序一致性的。Java中可以用valatile关键字。</p>
<pre><code>std::atomic&lt;int&gt; X(0), Y(0);
int r1, r2;

void thread1()
{
    X.store(1);
    r1 = Y.load();
}

void thread2()
{
    Y.store(1);
    r2 = X.load();
}
</code></pre><p>这样，不会出现X,Y均为0的现象；因为不会出现reorder。一般来说，编译器会加上memory fences或者使用RMW指令。相比于直接定义memory order，这种做法会有些额外的开销。</p>
<h3 id="Memory-Ordering"><a href="#Memory-Ordering" class="headerlink" title="Memory Ordering"></a>Memory Ordering</h3><p>如果环境不支持Sequential Consistency，需要自己确定，防止memory reorder。现有的技术条件下，方法有三：</p>
<ul>
<li>轻量级的sync或者fence指令</li>
<li>完全的内存fence指令</li>
<li>有着获取或者释放（Acquire and Release）的内存指令</li>
</ul>
<p>Acquire指令防止自己之后的指令跑到自己前面，Release指令防止之前的指令跑到自己后面。这种指令尤其在生产者消费者模型中很合适。</p>
<h3 id="Different-Processors-Have-Different-Memory-Models"><a href="#Different-Processors-Have-Different-Memory-Models" class="headerlink" title="Different Processors Have Different Memory Models"></a>Different Processors Have Different Memory Models</h3><p>比如PowerPC和ARM的芯片可能会更改有着内存相关性的指令顺序，而x86就不会。因此前者更复杂。幸好有着C++11这样的快平台模板，掩盖了底层的细节。但我认为，即使这样，程序员也应该意识到各个系统的差别。比如，x86每一个读内存都有个release指令；写内存都有一个acquire指令。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liumx10.github.io/2016/03/07/lock-free/" data-id="cili25sv00003pjclvj2vztyq" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/02/28/Branch-Prediction/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ouder</strong>
      <div class="article-nav-title">Branch-Prediction</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archieven</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recente berichten</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/03/07/lock-free/">lock-free</a>
          </li>
        
          <li>
            <a href="/2016/02/28/Branch-Prediction/">Branch-Prediction</a>
          </li>
        
          <li>
            <a href="/2016/02/28/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Mengxing Liu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>