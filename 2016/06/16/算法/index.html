<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>算法（上） | Dreamworks</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">算法（上）</h1><a id="logo" href="/.">Dreamworks</a><p class="description">Homepage</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">算法（上）</h1><div class="post-meta">Jun 16, 2016<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h1><h2 id="1-1-函数增长"><a href="#1-1-函数增长" class="headerlink" title="1.1 函数增长"></a>1.1 函数增长</h2><p>Θ: 渐进界，存在常数c1, c2，0 ≤ c1g(n) ≤ f(n) ≤ c2g(n)<br>O: 渐进上界，0 ≤ f(n) ≤ cg(n)<br>Ω: 渐进下界  0 ≤ cg(n) ≤ f(n)<br>o: 非渐进紧致上界，对任意正常数c &gt; 0,存在常数 n0&gt;0,使对所有的n ≥ n0,有0≤f(n)&lt;cg(n)<br>w: 非渐进紧致下界，类似上面。f(n) ∈ ω(g(n))当且仅当g(n) ∈ o(f(n))</p>
<p>函数间关系，满足传递性（所有）、自反性（Θ、O、Ω）、对此性（Θ）、转置对称。</p>
<p>有的函数之间无法有上面的关系比较。    </p>
<p>特殊函数：<br>对数函数： ln(1+x)的泰勒展开形式，任何多项式都比对数增长的快，非渐进紧致上界的关系。</p>
<p>阶乘函数： n!􏰄 = o(n^n);   n! = w(2^n); lg(n!)􏰄􏰌 = 􏰌􏰌Θ(nlgn)</p>
<p>函数迭代的定义。</p>
<p>多重对数函数。所以注意和对数的k次方之间的区别。增长最慢的函数了。</p>
<h2 id="1-2-分冶和递归"><a href="#1-2-分冶和递归" class="headerlink" title="1.2 分冶和递归"></a>1.2 分冶和递归</h2><h3 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MERGE-SORT(A, p, r)</span><br><span class="line"> <span class="keyword">if</span> p &lt; r</span><br><span class="line"> then q←⌊(p+r)/<span class="number">2</span>⌋</span><br><span class="line"> MERGE-SORT(A, p, q)</span><br><span class="line"> MERGE-SORT(A, q + <span class="number">1</span>, r)</span><br><span class="line"> MERGE(A, p, q, r)</span><br></pre></td></tr></table></figure>
<p>这是典型的分冶策略，本质是递归。运行时间也可以用一个递归方程来解。    </p>
<h3 id="最大子数组问题"><a href="#最大子数组问题" class="headerlink" title="最大子数组问题"></a>最大子数组问题</h3><p>输出连续子向量的最大和（长度不定）<br>方法一：遍历所有的子串 O(n^3)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = [<span class="number">0</span>, n)</span><br><span class="line"><span class="keyword">for</span> j = [i, n) </span><br><span class="line">	sum = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> k = [i, j] </span><br><span class="line">		sum += x[k]</span><br><span class="line">	maxsofar = max(maxsofar, sum)</span><br></pre></td></tr></table></figure></p>
<p>过程中浪费了一些信息，实际上x[i..j]和x[i..j-1]只差了一个x[j]，没有必要重新扫描算两遍。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">maxsofar = <span class="number">0</span> </span><br><span class="line"><span class="keyword">for</span> i = [<span class="number">0</span>, n)</span><br><span class="line">	sum = <span class="number">0</span> </span><br><span class="line">	<span class="keyword">for</span> j = [i, n)</span><br><span class="line">		sum += x[j]</span><br><span class="line">		maxsofar = max(maxsofar, sum)</span><br></pre></td></tr></table></figure></p>
<p>分冶算法，尽量等分，找出子部分最大子数组、同时找出跨划分节点的最大子数组。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">maxsum3</span><span class="params">(l, u )</span></span><br><span class="line">	<span class="title">if</span><span class="params">( l &gt; u )</span> return 0</span><br><span class="line">	<span class="title">if</span><span class="params">( l == u )</span></span><br><span class="line">		return <span class="title">max</span><span class="params">(<span class="number">0</span>,x[l])</span></span><br><span class="line">	m </span>= (l + u)/<span class="number">2</span></span><br><span class="line">	lmax = sum = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> ( i = m; i &gt;=l; i-- )</span><br><span class="line">		sum += x[i]</span><br><span class="line">		lmax = max(lmax, sum) </span><br><span class="line">	</span><br><span class="line">	rmax = sum = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i = (m, u]</span><br><span class="line">		sum += x[i]</span><br><span class="line">		rmax = max(rmax, sum)</span><br><span class="line">	<span class="keyword">return</span> max(lmax+rmax, maxsum3(l, m), maxsum3(m+<span class="number">1</span>, u))</span><br></pre></td></tr></table></figure></p>
<p>后面会给出说明，这个算法的复杂度为nlgn。</p>
<p>扫描算法：还有一种思路，如果我们已经解决了x[0..i-1]这个数组的问题，如何扩展到x[0..i]这个数组呢？想法很简单，要么x[0..i]直接使用之前的结果，即不包含第i个数；要么包含第i个数，最大子向量是一个数组的”尾巴“。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">maxsofar = <span class="number">0</span> maxendinghere = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i = [<span class="number">0</span>, n) <span class="comment">/* invariant: maxendinghere and maxsofar for x[0..i-1] </span><br><span class="line">	maxendinghere = max( maxendinghere+x[i], 0 )</span><br><span class="line">	maxsofar = max( maxsofar, maxendinghere )</span></span><br></pre></td></tr></table></figure></p>
<p>复杂度为O(n)</p>
<h3 id="递归树来解决时间复杂度"><a href="#递归树来解决时间复杂度" class="headerlink" title="递归树来解决时间复杂度"></a>递归树来解决时间复杂度</h3><p>求叶子节点个数、深度和每一层的复杂度。求个和即可。</p>
<h3 id="空间中最近的点"><a href="#空间中最近的点" class="headerlink" title="空间中最近的点"></a>空间中最近的点</h3><p>naive的算法，两两求距离，n的平方的复杂度。</p>
<p>分冶算法，两个部分内部最小距离、跨区域的最小距离。有意思的是跨区域怎么算，如果还是两两算，依旧是n的平方复杂度，没有意义了。所以做法是，先找出左右两边的子区域内最小距离d。然后筛选出距离分界线d范围以内的点。<br>同时呢，对于每一个p，只考虑在y方向上距离d以内的点。同时我们可以证明出这些点的个数在7个以内。所以是o(n)。</p>
<h2 id="递归式的解法"><a href="#递归式的解法" class="headerlink" title="递归式的解法"></a>递归式的解法</h2><h3 id="代换法"><a href="#代换法" class="headerlink" title="代换法"></a>代换法</h3><p>猜测某个界，然后用数学归纳法。可以和递归法配合着用。</p>
<p>需要注意的是确定边界条件。</p>
<h3 id="递归树法"><a href="#递归树法" class="headerlink" title="递归树法"></a>递归树法</h3><p>前面已经简单介绍过了。</p>
<h3 id="主方法"><a href="#主方法" class="headerlink" title="主方法"></a>主方法</h3><p>形如：T(n) = aT(n/b)+ f(n)<br><img src="/img/algorithm1.png" alt=""></p>
<p>强行记住公式即可。不考虑证明。</p>
<h1 id="2-排序"><a href="#2-排序" class="headerlink" title="2. 排序"></a>2. 排序</h1><h2 id="堆。"><a href="#堆。" class="headerlink" title="堆。"></a>堆。</h2><p>堆虽然是一个树状数据结构，但实际上是用数组存的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PARENT(i) = <span class="keyword">int</span>(i/<span class="number">2</span>)</span><br><span class="line">LEFT(i) = <span class="number">2</span>*<span class="function">i </span><br><span class="line"><span class="title">RIGHT</span><span class="params">(i)</span> </span>= <span class="number">2</span>*i +<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>最大堆父节点一定大于等于孩子；最小堆反之。</p>
<p>最大堆的调整是从上往下调整的。调整整个堆，需要对前n/2个节点（逆序）调整一次。所以上界是nlgn。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heap-size[A] ← length[A]</span><br><span class="line">fori← length[A]/<span class="number">2</span> downto <span class="number">1</span> 􏰀􏰁</span><br><span class="line">	<span class="keyword">do</span> MAX-HEAPIFY(A,i)</span><br></pre></td></tr></table></figure>
<p>证明的是每次循环开始的时候，都是一个最大堆的根。</p>
<p>简单上界很好判断，正如前文所说，nlgn，但不是紧确的。但通过求和计算，发现运行时间的界为O(n)</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>A[1]是最大的。所以把A[1]与A[n]交换，再把A[1..n-1]恢复成一个堆。依次类推。复杂度为nlgn。</p>
<h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>可以用堆实现。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MAXIMUM:  O(<span class="number">1</span>)</span><br><span class="line">EXTRACT-MAX: O(lgn)</span><br><span class="line">INSERT-KEY: O(lgn)</span><br><span class="line">INCREASE-KEY: O(lgn)</span><br></pre></td></tr></table></figure></p>
<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>平均性能最好，期望运行时间nlgn，最坏情况较差。</p>
<p>每次划分都是1, n-1，复杂度为n的平方。<br>只要按比例划分，都是nlgn。</p>
<p>加的优化是随机算法。用一个随机的数进行partition。</p>
<h2 id="比较排序的下界"><a href="#比较排序的下界" class="headerlink" title="比较排序的下界"></a>比较排序的下界</h2><p>用决策树模型，因为有n!种排列可能，每一个都需要在一个叶子节点中出现。之前说过log(n!) 复杂度为nlgn。所以树的高度至少为nlgn。</p>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>比较排序不是唯一的方法。计数排序可以达到o(n)的复杂度。基本思想是对于每一个数，求小于该数的元素的个数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i←<span class="number">0</span> to k</span><br><span class="line">	<span class="keyword">do</span> C[i]←<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j←<span class="number">1</span> to length[A]</span><br><span class="line">	<span class="keyword">do</span> C[A[j]] ← C[A[j]] + <span class="number">1</span></span><br><span class="line">	<span class="comment">//C[i] 现在包含等于i的元素个数 </span></span><br><span class="line"><span class="keyword">for</span> i←<span class="number">1</span> to k</span><br><span class="line">	<span class="keyword">do</span> C[i] ← C[i] + C[i - <span class="number">1</span>]</span><br><span class="line">	<span class="comment">//C[i]现在包含小于或等于i的元素个数  </span></span><br><span class="line"><span class="keyword">for</span> j← length[A] downto <span class="number">1</span></span><br><span class="line">	<span class="keyword">do</span> B[C[A[j]]] ← A[j]</span><br><span class="line">	C[A[j]] ← C[A[j]] - <span class="number">1</span></span><br><span class="line">	<span class="comment">// 为了防止相同的数</span></span><br></pre></td></tr></table></figure>
<p>最后一个循环使用downto的原因是，当值相同的时候，输出顺序和输入顺序的结果是一样的。这种属性称之为稳定的排序。</p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序和我们日常中排数字的概念差不多。按照位，一位一位的用一种稳定排序算法排序。<br><img src="/img/algorithm2.png" width="50%" height="50%"></p>
<p>n个d位数，d介于0-k之间。排序时间O(d(n+k))</p>
<p>如果连续r位，合并为一个数字，(b/r)(n+2^r):如果b&lt; lg(n)， r=b，直接O(n); 如果 b&gt;lg(n)，r取lg(n)，结果为bn/lgn。</p>
<p>注意点：</p>
<ol>
<li>常见情况是O(n)</li>
<li>但是常数因子较大</li>
<li>不是原地排序，耗内存。</li>
</ol>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>原理很简单，可以说是分冶的极致。但是每个桶里的数很少，很快就排完了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n←length[A]</span><br><span class="line"><span class="keyword">for</span> i← <span class="number">1</span> to n</span><br><span class="line">	<span class="keyword">do</span> insert A[i] into <span class="built_in">list</span> B[nA[i]]</span><br><span class="line"><span class="keyword">for</span> i← <span class="number">0</span> to n<span class="number">-1</span></span><br><span class="line">	<span class="keyword">do</span> sort <span class="built_in">list</span> B[i] with insertion sort</span><br><span class="line">concatenate the lists B[<span class="number">0</span>],B[<span class="number">1</span>],...,B[n<span class="number">-1</span>]together in order</span><br></pre></td></tr></table></figure></p>
<p>算出来期望是O(n)。</p>
<h2 id="中位数和顺序统计"><a href="#中位数和顺序统计" class="headerlink" title="中位数和顺序统计"></a>中位数和顺序统计</h2><h3 id="最大值和最小值"><a href="#最大值和最小值" class="headerlink" title="最大值和最小值"></a>最大值和最小值</h3><p>两两比较，小的和当前最小值比，大的和当前最大值比。3(n/2)的复杂度。</p>
<h3 id="顺序统计学"><a href="#顺序统计学" class="headerlink" title="顺序统计学"></a>顺序统计学</h3><p>输入n和i，求一个数，使得i-1个数比它小。</p>
<p>随机选择：借用快排的思想，但是每次只需要执行其中的一边。所以期望的复杂度是O(n)。数学证明略。</p>
<p>最坏情况的线性选择。</p>
<ol>
<li>将输入数组的n个元素划分为⌈n/5⌉组,每组 5个元素,且至多只有一个组由剩下的n mod 5个元素组成</li>
<li>寻找⌈n/5⌉个组中每一组的中位数,首先对 每组中的元素(至多为5个)进行插入排序, 然后从排序过的序列中选出中位数</li>
<li>对第2步中找出的⌈n/5⌉个中位数,递归调用 SELECT以找出其中位数x。(如果有偶数个 中位数,根据约定,x是下中位数)</li>
<li>利用修改过的PARTITION过程,按中位数 的中位数x对输入数组进行划分。让k比划分 低区的元素数目多1,所以x是第k小的元素, 并且有n-k个元素在划分的高区</li>
<li>如果i=k,则返回x； 否则如果i<k,在低区递归调用select以找出第i小的元素； 如果i="">k,在高区找出第(i-k)个最小元素</k,在低区递归调用select以找出第i小的元素；></li>
</ol>
<p>前三步只是用来找partition时候划分的数，第4步和第5步才是原来随机选择的办法。最后证明，在最坏的情况下，也能保证线性的时间。</p>
<h1 id="3-图计算"><a href="#3-图计算" class="headerlink" title="3. 图计算"></a>3. 图计算</h1><h2 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h2><p>G = {V, E},邻接表或者邻接矩阵。邻接表的存储空间为|E|,邻接矩阵为|V|*|V|</p>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>通过构建一个广度优先树。扫描每个节点的邻点，如果是白色，就在树中添加一个边，且把这个节点加入到准备队列里。</p>
<p>构建的搜索树可能不同，但是深度肯定是一样的。</p>
<p>复杂度：O(V+E)</p>
<p>算出来的d值，一定是距离s的最短路径。证明略。</p>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> each vertex u ∈ V [G] </span><br><span class="line">	<span class="keyword">do</span> color[u] ← WHITE</span><br><span class="line">		π[u] ← NIL </span><br><span class="line">time ← <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> each vertex u ∈ V [G] </span><br><span class="line">	<span class="keyword">do</span> <span class="keyword">if</span> color[u] = WHITE</span><br><span class="line">		then DFS-VISIT(u)</span><br><span class="line"></span><br><span class="line">DFS-VISIT(u)</span><br><span class="line">	color[u] ← GRAY  <span class="comment">//白色结点u已被发现 2 time ← time +1</span></span><br><span class="line">	d[u] ← time</span><br><span class="line">	<span class="keyword">for</span> each v ∈ Adj[u] <span class="comment">//探寻边(u,v)</span></span><br><span class="line">		<span class="keyword">do</span> <span class="keyword">if</span> color[v] = WHITE then </span><br><span class="line">			π[v] ← u</span><br><span class="line">			DFS-VISIT(v)</span><br><span class="line">	color[u] ← BLACK <span class="comment">//完成后置u为黑色.</span></span><br><span class="line">	f[u] ← time ← time +<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>所以最后获得的是一个深度优先森林。复杂度也是O(V+E).</p>
<p>d[u]和f[u]构成了一个区间，要么完全没关系，要么完全覆盖，由此判断两个点的关系。</p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>定义：图的所有顶点沿水平排列，所有的有向边均从左指向右。</p>
<p>做法：用DFS，一个顶点完成的时候（f)插到链表前端。</p>
<p>引理：有向图G无回路当且仅当对G进行深度优先搜索没有得到反向边</p>
<p>证明拓扑排序就按照f的时间比较即可。</p>
<h2 id="强连通分支"><a href="#强连通分支" class="headerlink" title="强连通分支"></a>强连通分支</h2><p>定义：任何两个顶点互相可达，称为强连通图。<br>G的强连通子图称为强连通分支。</p>
<ol>
<li>调用DFS(G)计算每个节点完成时间f(u)</li>
<li>求图的转置。</li>
<li>调用DFS(G^T),主循环里按f(u)递减的顺序考虑各个顶点。</li>
<li>输出每个深度优先森林的顶点。</li>
</ol>
<p>收缩之后得到一个分支图。分支图一定是无环的。复杂度为O(V+E)</p>
<h3 id="算法证明"><a href="#算法证明" class="headerlink" title="算法证明"></a>算法证明</h3><p>可以在第三行的G^T做归纳。可以证明每一颗树的节点都形成一个强连通分支。归纳假设是前k个树都是强连通分支。<br>k=0的时候，没有任何树，显而成立。</p>
<p>归纳假设前k个树都是强连通，现在考虑第k+1个树。设顶点为u，位于强连通分量C中。</p>
<p>根据优先根的选择方式，对于其他任何将要访问的强连通分支，f[u] = f(C) &gt; f(C’).当搜到u的时候，C中其他顶点都是白色的。所以C这棵深度优先树，u为顶点。</p>
<p>根据推论，如果在G^T中存在(u,v)，u在C中，v在C’中，那么f(C) &lt; f(C’)。又因为f(C)是当前最大的了，所以不会存在u指向其他没有分离出来的C‘。也就是说，离开该C的边都是指向已经搜索过的边了。</p>
<p>所以，根为u的深度优先树恰好是一个强连通分支。</p>
<h2 id="搜索问题"><a href="#搜索问题" class="headerlink" title="搜索问题"></a>搜索问题</h2><p>求一个n元组的解使得准则函数最大化。变量取值范围为有限集合。</p>
<p>解可以看做是一个空间状态树。</p>
<p>如果暴利搜索太慢了，所以会用到一些剪枝的方法。而要用好剪枝，需要构造好树的结构和搜索顺序。</p>
<h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p>略</p>
<h3 id="分支定界法"><a href="#分支定界法" class="headerlink" title="分支定界法"></a>分支定界法</h3><p>搜索的时候，一个节点只有一次能成为活跃节点（生成所有的子节点），同时会有一个下限（求最小化问题）或者上限（求最大化问题），用来方便剪枝。</p>
<p>应该会考，所以看下ppt上的例题。尤其是旅行商问题。精妙之处在于选择一个点，确定走不走这条路。在此这个地方分叉为两个节点。</p>
<h3 id="启发式搜索"><a href="#启发式搜索" class="headerlink" title="启发式搜索"></a>启发式搜索</h3><p>略</p>
<h1 id="4-动态规划"><a href="#4-动态规划" class="headerlink" title="4. 动态规划"></a>4. 动态规划</h1><p>动态规划的问题核心在于划分子问题。</p>
<h2 id="钢条问题"><a href="#钢条问题" class="headerlink" title="钢条问题"></a>钢条问题</h2><p>核心点在于，问题的分析。先切一刀，左边的再也不切了，右边还有可能切。所以分成了若干个子问题去求解。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">MEMOIZED-CUT-ROD(p, n) </span><br><span class="line">	let r[<span class="number">0.</span>..n] be a <span class="keyword">new</span> <span class="built_in">array</span> </span><br><span class="line">	<span class="keyword">for</span> i=<span class="number">0</span> to n</span><br><span class="line">		r[i]= MIN_INT</span><br><span class="line">	<span class="keyword">return</span> MEMOIZED-CUT-ROD-AUX(p, n, r)</span><br><span class="line"></span><br><span class="line">MEMOIZED-CUT-ROD-AUX(p, n, r)</span><br><span class="line">	<span class="keyword">if</span> r[n]&gt;=<span class="number">0</span></span><br><span class="line">		<span class="keyword">return</span> r[n] </span><br><span class="line">	<span class="keyword">if</span> n==<span class="number">0</span></span><br><span class="line">		q=<span class="number">0</span> </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		q= MIN_INT</span><br><span class="line">	<span class="keyword">for</span> i= <span class="number">1</span> to n </span><br><span class="line">		q=max(q,p[i]+MEMOIZED-CUT-ROD-AUX(p,n-i,r))</span><br><span class="line">	</span><br><span class="line">	r[n]=q </span><br><span class="line">	<span class="keyword">return</span> q</span><br></pre></td></tr></table></figure></p>
<p>也可用自底向上，只不过不用递归了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let r[<span class="number">0.</span>..n] be a <span class="keyword">new</span> <span class="built_in">array</span></span><br><span class="line">	r[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j=<span class="number">1</span> to n</span><br><span class="line">	q= MIN_INT</span><br><span class="line">	<span class="keyword">for</span> i=<span class="number">1</span> to j</span><br><span class="line">		q=max(q,p[i]+r[j-i]) </span><br><span class="line">	r[j]=q</span><br><span class="line"><span class="keyword">return</span> r[n]</span><br></pre></td></tr></table></figure>
<p>保留切割信息也很简单，就是保留切割n的时候，第一刀下在哪里。在print的时候，逆序打印出来即可。</p>
<h2 id="矩阵链乘法"><a href="#矩阵链乘法" class="headerlink" title="矩阵链乘法"></a>矩阵链乘法</h2><p>这个核心在于，子问题是A[i..j]。子问题的个数只有2^n个。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自底向上</span></span><br><span class="line"></span><br><span class="line">MATRIX-CHAIN-ORDER(p) </span><br><span class="line">n ← length[p] - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i ← <span class="number">1</span> to n</span><br><span class="line">    <span class="keyword">do</span> m[i, i] ← <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> l ← <span class="number">2</span> to n <span class="comment">// l is the chain length.</span></span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">for</span> i ← <span class="number">1</span> to n - l + <span class="number">1</span>   <span class="comment">// A[i..j]</span></span><br><span class="line">        <span class="keyword">do</span> j ← i + l - <span class="number">1</span></span><br><span class="line">            m[i, j] ← ∞</span><br><span class="line">            <span class="keyword">for</span> k ← i to j - <span class="number">1</span></span><br><span class="line">                <span class="keyword">do</span> q ← m[i, k] + m[k+<span class="number">1</span>, j] + pi<span class="number">-1</span>pkpj </span><br><span class="line">                <span class="keyword">if</span> q &lt; m[i, j]</span><br><span class="line">                    then m[i, j] ← q </span><br><span class="line">                    s[i, j] ← k</span><br><span class="line"><span class="keyword">return</span> m and s</span><br></pre></td></tr></table></figure></p>
<h2 id="动态规划问题的特征"><a href="#动态规划问题的特征" class="headerlink" title="动态规划问题的特征"></a>动态规划问题的特征</h2><p>有最优子结构的问题，一定可以用动态规划来做；反之，不一定。算法复杂度为子问题个数*每个子问题的选择个数。如钢条问题为n的平方，矩阵问题为n的三次方。</p>
<p>所以，对于无权最短路径，有最优子结构；无权最长路径，无最优子结构。</p>
<p>子问题独立：一个子问题的解，不会影响同一个问题中另外一个子问题的解。如无权最长路径，确定前一个最长子路，后面一个子路不能和前面的交叉，于是就有了影响。</p>
<p>另外一个基本性质是子问题的重叠性；即子问题不用重新计算。</p>
<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">	C[i, j] = <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( x[i] == y[j] )</span><br><span class="line">	C[i, j] = C[i<span class="number">-1</span>, j<span class="number">-1</span>]+<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	C[i, j] = max(C[i<span class="number">-1</span>, j], C[i, j<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<h2 id="最优二叉搜索树"><a href="#最优二叉搜索树" class="headerlink" title="最优二叉搜索树"></a>最优二叉搜索树</h2><p>有点类似于矩阵链乘。有子树K[i..j],d[i-1,j],该子树肯定是最优的。</p>
<p>所以看连续范围内的搜索代价问题。<br>e[i, j] = q[i-1]    if j==i-1<br>e[i, j] = min{e[i, r-1] + e[r+1, j] + w[i, j]}   if i&lt;= j</p>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p>这个和图算法有点区别。设 $l_{i,j}^{(m)}$ 为从i到j至多包含m条边的最短路。可以构建递归式。<br>$$ l_{i,j}^{(m)} = min ( l_{i,k}^{(m-1)} + w_{k,j} ) $$</p>
<p>有点类似于矩阵乘法，只要算出$l^{n-1}$来即可。因为之后肯定都一样。</p>
<p>可以根据传统的矩阵结合律，先算l(1)，再算l(2)，l(4),l(8)…所以复杂度时间降为$n^3lgn$。</p>
<h2 id="Floyd-Warshall算法"><a href="#Floyd-Warshall算法" class="headerlink" title="Floyd-Warshall算法"></a>Floyd-Warshall算法</h2><p>该算法是一种升级版，可以将复杂度降到n的三次方。基于的观察是i到j，所有中间节点都属于{1，2，3，…，k}时候的最短路径。</p>
<ol>
<li>如果k不是中间节点，那么中间节点都在{1,2,3,…,k-1}中。</li>
<li>如果k是中间节点，可以分成两个部分，i到k和k到j，同样，这两条路的中间节点都不会经过k，只属于{1,2,3,…,k-1}</li>
</ol>
<p>所以定义$d_{ij}^{(k)}$为满足中间节点都在{1,2,3,…,k}的最短路的权值。如果集合为空，表示没有中间节点。</p>
<ol>
<li>if k=0      $d_{ij}^{(k)} = w_{ij}$</li>
<li>else        $d_{ij}^{(k)} = min(d_{ij}^{(k-1)}, d_{ik}^{(k-1)}+d_{kj}^{(k-1)} )$</li>
</ol>
<p>每一轮k，只需要n的平法次复杂度即可。而不像原来需要n的三次方。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://liumx10.github.io/2016/06/16/算法/" data-id="ck0ntobtv001nzifybq7qwylh" class="article-share-link">Share</a><div class="tags"><a href="/tags/课程笔记/">课程笔记</a></div><div class="post-nav"><a href="/2016/06/18/算法-下/" class="pre">算法(下)</a><a href="/2016/06/12/tpc-c/" class="next">tpc-c</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://liumx10.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/distributed-system/" style="font-size: 15px;">distributed system</a> <a href="/tags/concurrency-control/" style="font-size: 15px;">concurrency control</a> <a href="/tags/computer-structure/" style="font-size: 15px;">computer structure</a> <a href="/tags/big-data/" style="font-size: 15px;">big data</a> <a href="/tags/课程笔记/" style="font-size: 15px;">课程笔记</a> <a href="/tags/NVML/" style="font-size: 15px;">NVML</a> <a href="/tags/OLTP/" style="font-size: 15px;">OLTP</a> <a href="/tags/Transactional-Memory/" style="font-size: 15px;">Transactional Memory</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/03/07/cc-5-1/">cc-5-1</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/20/Speedup-RW-conflict-tracking-in-PostgreSQL/">Speedup RW-conflict tracking in PostgreSQL</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/29/pmemlib-1/">NVM library 源码分析(1) libpmem</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/25/core/">core-chip-processor-socket等的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/06/tsx/">tsx</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/21/BigTable/">BigTable</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/21/dynamo/">dynamo</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/21/spark/">spark</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/21/dryad/">dryad</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/19/MapReduce/">MapReduce</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://madsys.cs.tsinghua.edu.cn/" title="madsys" target="_blank">madsys</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Dreamworks.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/x-mathjax-config">MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
      tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
      TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
      messageStyle: "none"
  });
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>