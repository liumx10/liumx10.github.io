<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Speedup RW-conflict tracking in PostgreSQL | Dreamworks</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Speedup RW-conflict tracking in PostgreSQL</h1><a id="logo" href="/.">Dreamworks</a><p class="description">Homepage</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Speedup RW-conflict tracking in PostgreSQL</h1><div class="post-meta">Aug 20, 2017<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><h2 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h2><ul>
<li><a href="https://github.com/liumx10/pg-bench" target="_blank" rel="external">benchmarks</a></li>
<li><a href="/resources/gsoc-htab.patch">hash table patch</a> </li>
<li><a href="/resources/skiplist.patch">skip list patch</a></li>
<li><a href="/resources/finerlock.patch">finer lock patch</a></li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>PostgreSQL needs to track read-write conflicts (rw-conflict) among transactions executed concurrently at runtime. It uses a linked-list in the shared memory to record all conflicts of each transaction. Some benchmarks reproted that conflict-tracking took up a lot of CPU time at high concurrency levels. Using a faster data structure may help to speedup conflict-tracking.</p>
<h2 id="Benchmarks"><a href="#Benchmarks" class="headerlink" title="Benchmarks"></a>Benchmarks</h2><p>Current PostgreSQL benchmark tool <a href="https://www.postgresql.org/docs/9.6/static/pgbench.html" target="_blank" rel="external">pgbench</a> can’t be used for serilizable transactions, because the program would exit if there is a transaction aborted by serilizable detecting. Thus I developed a new benchmarks to compare performance. It is a benchmark framework developed by GO and can be extended with new benchmarks easily. Now there are three benchmarks: ssibench, simple ssibench and tpcb. You can get more information in the <a href="https://github.com/liumx10/pg-bench" target="_blank" rel="external">github</a>. The framework can also be used by other projects related to PG serilizable transactions in future.</p>
<h2 id="Alternative-data-structures-hash-table-amp-skip-list"><a href="#Alternative-data-structures-hash-table-amp-skip-list" class="headerlink" title="Alternative data structures: hash table &amp; skip list"></a>Alternative data structures: hash table &amp; skip list</h2><p>We chose hash table and skip list to replace linked list to record conflicts, because the time complexities for searching of hash table and skip list are O(1) and O(logN) respectively. </p>
<p>However, after implementation we found these two data structures could not improve the performance for the reasons below:</p>
<ol>
<li><p>The length of conflict list is not as long as we expected. In all benchmarks, 50% lists are shorter than 10, and all lists are shorter than 40. In this case, conflict tracking consumes less than 2% CPU time. </p>
</li>
<li><p>There are three basic functions maintaining conflicts information: </p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Checking if a transaction is in the conflict list of another transaction */</span></span><br><span class="line">RWConflictExists;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Inserting one transaction into the conflict list of another transaction and vice versa */</span></span><br><span class="line">SetRWConflict;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Removing one transaction from the conflict list of another transaction and vice verse */</span></span><br><span class="line">ReleaseRWConflict;</span><br></pre></td></tr></table></figure>
<p>Take skip list for example, it can speedup the function RWConflictExists, because searching complexity of skip list is O(logN). However, it makes SetRWConflict slower, because the inserting complexity of skip list is O(logN) while the inserting complexity of linked list is O(1). </p>
<p>Hash table has the same problem. Even its time complexities of searching, inserting and removing are both O(1), constant factors are much bigger than the linked list. </p>
<p>In a summary, hash table and skip list couldn’t improve the performance. Actually, I don’t think other common data structure (e.g. tree) can help. If one data structure can speedup the function RWConflictExists, it would make the other two functions slower. It’s my fault that I didn’t realize this consequence when writing the proposal. But the experience could be helpful for other developers.  </p>
<h2 id="Reduce-contention-on-the-global-lock"><a href="#Reduce-contention-on-the-global-lock" class="headerlink" title="Reduce contention on the global lock"></a>Reduce contention on the global lock</h2><p>There are many global locks used in PostgreSQL serilizable transaction model. I found waiting for locks took up much more time than conflict tracking when I profile the performance. SerializableFinishedListLock is one of locks which caused a lot of contention. </p>
<p>In PostgreSQL, a transaction can cause another transaction being aborted even when it is finished. Thus transactions can’t be released immediately whey they are finished. There is a list called FinishedSerializableTransactions maintaining these transactions. The SerializableFinishedListLock is used to protect this list. </p>
<p>The function ClearOldPredicateLocks is used to release finished transactions, the pseudo code is as below:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lock</span>(SerializableFinishedListLock)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> tx <span class="keyword">in</span> FinishedSerializableTransactions:</span><br><span class="line">    <span class="keyword">if</span> tx can be released:</span><br><span class="line">        ReleaseOneSerializableXact(tx);</span><br><span class="line">        remove tx from FinishedSerializableTransactions </span><br><span class="line"></span><br><span class="line"><span class="keyword">unlock</span>(SerializableFinishedListLock)</span><br></pre></td></tr></table></figure>
<p>The function ReleaseOneSerializableXact takes up most time of ClearOldPredicateLocks. Actually, it doesn’t need the protection of SerializableFinishedListLock. Thus we can move it out the critical path so that there will be less contention on the lock. Here is the new pseudo code:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector releasedTx; </span><br><span class="line"><span class="keyword">lock</span>(SerializableFinishedListLock)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> tx <span class="keyword">in</span> FinishedSerializableTransactions:</span><br><span class="line">    <span class="keyword">if</span> tx can be released:</span><br><span class="line">        releasedTx.<span class="keyword">insert</span>(tx);</span><br><span class="line">        remove tx from FinishedSerializableTransactions </span><br><span class="line"></span><br><span class="line"><span class="keyword">unlock</span>(SerializableFinishedListLock)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> tx <span class="keyword">in</span> releasedTx:</span><br><span class="line">    ReleaseOneSerializableXact(tx);</span><br></pre></td></tr></table></figure>
<p>Here is the result. I used <a href="https://github.com/liumx10/pg-bench" target="_blank" rel="external">simple ssibench</a> as the benchmark. The red line indicates the performance of the original code, while the blue line indicates the performance of the new code. When the number of clients is small, lock contention is not the bottleneck so there is no much difference. When there are 24 or 36 clients, the new version is at most 14% faster. When there are too many clients, contentions on a finer lock, i.e. predicate lock, become the new bottleneck. Thus the performances of two versions are similiar again. </p>
<p><img src="/img/gsoc1.png" alt=""></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In this project:<br>1) I provide a systematic benchmark for PostgreSQL. The existing benchmark tool pgbench can’t be used for serializable transactions.<br>2) I tried to use a faster data structure to speedup conflict-tracking but found that other parts would be slower and the performance couldn’t be improved.<br>3) I provided a new patch to reduce contentions on the global lock, which can be 14% faster than the old version in some cases. </p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://liumx10.github.io/2017/08/20/Speedup-RW-conflict-tracking-in-PostgreSQL/" data-id="cjy9jl905000fu5wijob6rfbp" class="article-share-link">Share</a><div class="tags"></div><div class="post-nav"><a href="/2019/03/07/cc-5-1/" class="pre">cc-5-1</a><a href="/2016/08/29/pmemlib-1/" class="next">NVM library 源码分析(1) libpmem</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://liumx10.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/distributed-system/" style="font-size: 15px;">distributed system</a> <a href="/tags/concurrency-control/" style="font-size: 15px;">concurrency control</a> <a href="/tags/computer-structure/" style="font-size: 15px;">computer structure</a> <a href="/tags/big-data/" style="font-size: 15px;">big data</a> <a href="/tags/课程笔记/" style="font-size: 15px;">课程笔记</a> <a href="/tags/NVML/" style="font-size: 15px;">NVML</a> <a href="/tags/OLTP/" style="font-size: 15px;">OLTP</a> <a href="/tags/Transactional-Memory/" style="font-size: 15px;">Transactional Memory</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/07/19/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/07/cc-5-1/">cc-5-1</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/20/Speedup-RW-conflict-tracking-in-PostgreSQL/">Speedup RW-conflict tracking in PostgreSQL</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/29/pmemlib-1/">NVM library 源码分析(1) libpmem</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/25/core/">core-chip-processor-socket等的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/06/tsx/">tsx</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/21/BigTable/">BigTable</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/21/dynamo/">dynamo</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/21/spark/">spark</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/21/dryad/">dryad</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://madsys.cs.tsinghua.edu.cn/" title="madsys" target="_blank">madsys</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Dreamworks.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/x-mathjax-config">MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
      tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
      TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
      messageStyle: "none"
  });
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>